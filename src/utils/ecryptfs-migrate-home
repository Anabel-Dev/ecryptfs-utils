#!/bin/sh
# -*- sh-basic-offset: 4; sh-indentation: 4; tab-width: 4; indent-tabs-mode: t; sh-indent-comment: t; -*-
# This script encrypts an user's home
#
# Written by Yan Li <yan.i.li@intel.com>, <yanli@gnome.org>
# Copyright (C) 2010 Intel Corporation
#
# Some house cleaning by Dustin Kirkland <kirkland@canonical.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

set -e

# consts
# ENCRYPT_TAG_FILE_NAME can't contain spaces
ENCRYPT_TAG_FILE_NAME=.ENCRYPT_ME_ON_NEXT_BOOT
PRIVATE_DIR="Private"

usage() {
       echo "
Usage:

$0 [-e|-s|-b]

This program has 3 different modes, User mode (-e), Administrator mode (-s),
and Boot mode (-b).

User mode...
$0 -e USER [-l|--loginpass LOGINPASS] [-m|--mountpass MOUNTPASS] [-v|--verbose]

 -e, --encrypt    Encrypt USER's home in place
                   * NOTE: only root can run this
 -l, --loginpass  Login/Wrapping passphrase for USER,
                  used to wrap MOUNTPASS
 -m, --mountpass  Passphrase for mounting the ecryptfs directory,
                  defaults to randomly generated
 -v, --verbose    Output debug messages

Administrator mode...
$0 -s
 -s, --setup      Set up encryption for current user to run on next boot,
                   * NOTE: non-root users can run this

Boot mode...
$0 -b
 -b, --boot       Boot mode. Use this option on boot to do encryption on
                  demand. SHOULD ONLY BE CALLED from a boot script. You
                  should NOT use this option directly, (only root
                   * NOTE: only root can run this in an init script

This program encrypts an user's home directory.

There are two ways to use this script:

 a. you can run this script as root, to encrypt any directory by using
    the -e option. You have to make sure that directory is not in use
    (the script will also check for this)

 b. if your distro supports this, you can also run this script a a
    normal user with -s (or --setup) to setup encryption to run on
    next reboot, and your home will be automatically encrypted on next
    boot. If your distro didn't support this, running with -s is no
    use

WARNING: Make a complete backup copy of your non-encrypted data to
another system or external media. This script is dangerous and, in
case of an error, could result in data lost, or lock you out of your
system!

"
       exit 1
}

error() {
       echo "$(gettext 'ERROR: ')" "$@" 1>&2
       exit 1
}

warning() {
       echo "$(gettext 'WARNING: ')" "$@" 1>&2
}

debug() {
       if [ "$VERBOSE" = "1" ]; then
               echo "$(gettext 'DEBUG: ')" "$@" 1>&2
       fi
}

assert_dir_empty() {
       # arguments:
       local DIR=${1}

       if [ -e "${DIR}" ]; then
               # if ${DIR} is a directory, make sure it's empty
               if [ -d "${DIR}" ]; then
			ls=$(ls -A "${DIR}" | wc -l)
                       if [ "$ls" != "0" ]; then
                               echo 1>&2 "If you already have some data in directory ${DIR},"
                               echo 1>&2 "please move all of these files and directories out of the way, and"
                               echo 1>&2 "follow the instructions in:"
                               echo 1>&2 "    ecryptfs-setup-private --undo"
                               echo 1>&2 
                               error "${DIR} is not empty, can't continue"
                       fi
               else
                       error "${DIR} exists but is not an empty directory, can't continue"
               fi
       fi
}

# get user home by id
get_user_home () {
       local USER_ID=$1

       local USER_HOME=$(grep "^${USER_ID}:" /etc/passwd | cut -d":" -f 6)
       if [ -z "$USER_HOME" ]; then
               error "Can't find user home for $USER_ID"
       fi

       echo $USER_HOME
}

# get user id by home
get_user_id () {
       local USER_HOME=$1

       local USER_ID=$(grep -F ":${USER_HOME}:" /etc/passwd | cut -d":" -f 1)
       if [ -z "$USER_ID" ]; then
               error "Can't find user home for $USER_ID"
       fi

       echo $USER_ID
}

sanity_check () {
       # arguments:
       # remove trailing "/"
       local USER_ID=${1}
       local USER_HOME=${2%/}

       # Is $USER_HOME a mountpoint?
       if mount | grep -q -F " ${USER_HOME} "; then
               error "${USER_HOME} is a mountpoint or it's already encrypted, we can't migrate it for now"
       fi

       # Check for rsync
       if ! which rsync >/dev/null 2>&1; then
               error "Please install the rsync package"
       fi

       # Check free space: make sure we have sufficient disk space
       # available. To make a full copy, we will need at least 2x the
       # disk usage of the target home directory.

       # TODO: not implemented yet
       # if DO_NOT_HAVE_ENOUGH_SPACE; then
       #       error "not enough free space, I need at least 2x the disk usage of your current home directory"
       # fi

       # Check directories
       assert_dir_empty "${USER_HOME}.old" && rm -rf "${USER_HOME}.old"
       assert_dir_empty "${USER_HOME}/.${PRIVATE_DIR}"
       assert_dir_empty "${USER_HOME}/.ecryptfs"
       assert_dir_empty "/home/.ecryptfs/${USER_ID}"
}

encrypt_dir ()
{
       # argument:
       # remove trailing "/"
       local USER_ID=$1
       local USER_HOME=${2%/}
       local LOGINPASS=${3}
       local MOUNTPASS=${4}

       # check whether USER_HOME is in use
       if ! which lsof >/dev/null 2>&1; then
               warning "lsof not found, I don't know whether your home is in use or not"
       else
               debug "checking for open files in $USER_HOME"
		lsof=$(lsof +D "$USER_HOME" | wc -l)
               if [ "$lsof" != "0" ]; then
                       lsof +D "$USER_HOME"
                       echo
                       error "user ${USER_ID} has opened the files above, can't proceed"
               fi
       fi

       # start encryption
       mv "${USER_HOME}" "${USER_HOME}.old"
       mkdir -p -m 700 "${USER_HOME}"
       chown -R ${USER_ID}.${USER_ID} "${USER_HOME}"
       ECRYPTFS_SETUP_PRIVATE_ARGS=""
       if [ -n "$LOGINPASS" ]; then
               ECRYPTFS_SETUP_PRIVATE_ARGS="-l ${LOGINPASS}"
       fi
       if [ -n "$MOUNTPASS" ]; then
               ECRYPTFS_SETUP_PRIVATE_ARGS="$ECRYPTFS_SETUP_PRIVATE_ARGS -m ${MOUNTPASS}"
       fi
       if ! ecryptfs-setup-private -u "$USER_ID" -b $ECRYPTFS_SETUP_PRIVATE_ARGS; then
               # too bad, something went wrong, we'll try to recover
               rm -rf "${USER_HOME}"
               mv "${USER_HOME}.old" "${USER_HOME}"
               exit 1
       fi
       debug "encrypt home has been set up, encrypting files now..."
       rsync -a "${USER_HOME}.old/" "${USER_HOME}/"
       umount "${USER_HOME}/"
}

DO_SETUP=
DO_BOOT=
DO_ENCRYPT=
VERBOSE=
while true; do
       [ -z "$1" ] && break
       case "$1" in
               -u|--username)
                       USER="$2"
                       shift 2
                       ;;
               -l|--loginpass)
                       LOGINPASS="$2"
                       shift 2
                       ;;
               -m|--mountpass)
                       MOUNTPASS="$2"
                       shift 2
                       ;;
               -w|--wrapping)
                       WRAPPING_PASS="INDEPENDENT"
                       MESSAGE="$(gettext 'Enter your wrapping passphrase')"
                       shift 1
                       ;;
               -s|--setup)
                       DO_SETUP=1
                       shift 1
                       ;;
               -b|--boot)
                       DO_BOOT=1
                       shift 1
                       ;;
               -v|--verbose)
                       VERBOSE=1
                       shift 1
                       ;;
               -e|--encrypt)
                       DO_ENCRYPT=1
                       USER_ID=$2
                       USER_HOME=$(get_user_home ${USER_ID})
                       shift 2
                       ;;
               *)
                       usage
                       ;;
       esac
done

if [ "$DO_SETUP""$DO_BOOT""$DO_ENCRYPT" != "1" ]; then
       usage
fi

if [ "$DO_SETUP" = "1" ]; then
       # we can't encrypt root's home
       if [ "$(id -u)" = "0" ]; then
               error "can't encrypt root's home, you should use setup as a normal user"
       fi

       # LOGINPASS and MOUNTPASS will just be ignored here
       if [ -n "${LOGINPASS}" ] || [ -n "${MOUNTPASS}" ]; then
               warning "Setting up encryption on next boot, and LOGINPASS/MOUNTPASS will just be ignored. A random MOUNTPASS will be generated automatically"
       fi

       sanity_check $HOME

       # set up a tag
       touch ~/${ENCRYPT_TAG_FILE_NAME}

       echo "Your home directory will be encrypted at the next reboot"
       exit 0
fi

if [ "$DO_BOOT" = "1" ]; then
       # I must be run as root now
       if [ "$(id -u)" != "0" ]; then
               error "boot mode can only be used as root"
       fi

       # search for ENCRYPT_TAG_FILE_NAME, FIXME: now we handle the first
       # one only fow now
       USER_HOME=$(ls /home/*/${ENCRYPT_TAG_FILE_NAME} 2>/dev/null | head -1)
       USER_HOME=${USER_HOME%/*}
       if [ -z "$USER_HOME" ]; then
               debug "no encrypt tag file found, bye"
               exit 0
       fi
       USER_ID=$(get_user_id "${USER_HOME}")

       rm -f "${USER_HOME}/${ENCRYPT_TAG_FILE_NAME}"

       # check for ecryptfs kernel module
       lsmod | grep -q ecryptfs || {
               modprobe ecryptfs
       }

       sanity_check "$USER_ID" "$USER_HOME"
       encrypt_dir "$USER_ID" "$USER_HOME"
       exit 0
fi

if [ "$DO_ENCRYPT" = "1" ]; then
       sanity_check "$USER_ID" "$USER_HOME"
       encrypt_dir "$USER_ID" "$USER_HOME" "${LOGINPASS}" "${MOUNTPASS}"
       exit 0
fi
