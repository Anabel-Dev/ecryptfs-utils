#!/bin/sh
# This script sets up an ecryptfs mount in a user's ~/Private
#
# Originally ecryptfs-setup-pam-wrapped.sh by Michael Halcrow, IBM
#
# Ported for use on Ubuntu by Dustin Kirkland <kirkland@canonical.com>
# Copyright (C) 2008 Canonical Ltd.
# Copyright (C) 2007-2008 International Business Machines
PRIVATE_DIR="Private"
WRAPPING_PASS="LOGIN"
PW_ATTEMPTS=3
MESSAGE="Enter your login passphrase"

# Zero out user-defined GREP_OPTIONS, such as --line-number
GREP_OPTIONS=

usage() {
	echo
	echo "Usage:"
	echo "# $0 [-f|--force] [-w|--wrapping] [-u|--username USER]"
	echo "  [-l|--loginpass LOGINPASS] [-m|--mountpass MOUNTPASS]"
	echo
	echo " -f, --force      Force overwriting of an existing setup"
	echo " -w, --wrapping   Use an independent wrapping passphrase,"
	echo "                different from the login passphrase"
	echo " -u, --username   Username for encrypted private mountpoint,"
	echo "                defaults to yourself"
	echo " -l, --loginpass  Login/Wrapping passphrase for USER,"
	echo "                used to wrap MOUNTPASS"
	echo " -m, --mountpass  Passphrase for mounting the ecryptfs directory,"
	echo "                defaults to a randomly generated 16 bytes"
	echo " -a,--all-home   Encrypt the entire home directory"
	echo
	echo "   Be sure to properly escape your parameters according to your"
	echo "   shell's special character nuances, and also surround the"
	echo "   parameters by double quotes, if necessary."
	echo
	exit 1
}

error() {
	echo "ERROR: $1"
	exit 1
}

error_testing() {
	rm -f "$1" >/dev/null
	/sbin/umount.ecryptfs_private >/dev/null
	error "$2"
	exit 1
}

if [ ! -z "$SUDO_USER" ]; then
	USER="$SUDO_USER"
fi

while [ ! -z "$1" ]; do
	case "$1" in
		-u|--username)
                        USER="$2"
			shift 2
		;;
		-l|--loginpass)
			LOGINPASS="$2"
			shift 2
		;;
		-m|--mountpass)
			MOUNTPASS="$2"
			shift 2
		;;
		-w|--wrapping)
			WRAPPING_PASS="INDEPENDENT"
			MESSAGE="Enter your wrapping passphrase"
			shift 1
		;;
		-f|--force)
			FORCE=1
			shift 1
		;;
		-a|--all-home)
			ALLHOME=1
			shift 1
		;;
		*)
			usage
		;;
	esac
done

# Prompt for the USER name, if not on the command line and not in the environment
if [ -z "$USER" ]; then
	while [ true ]; do
		read -p "Enter the username: " -r USER
		if [ -z "$USER" ]; then
			echo "ERROR: You must provide a username"
			continue
		else
			# Verify that the user exists
			if ! id "$USER" >/dev/null; then
				echo "ERROR: User [$USER] does not exist"
				continue
			fi
			break
		fi
	done
else
	# Verify that the user exists
	id "$USER" >/dev/null || error "User [$USER] does not exist"
fi

# Obtain the user's home directory
HOME=`getent passwd "$USER" | awk -F: '{print $6}'`
if [ ! -d "$HOME" ]; then
	error "User home directory [$HOME] does not exist"
fi

# Check for previously setup private directory
if [ -s "$HOME/.ecryptfs/wrapped-passphrase" -a "$FORCE" != "1" ]; then
	error "wrapped-passphrase file already exists, use --force to overwrite."
fi
if [ -s "$HOME/.ecryptfs/$PRIVATE_DIR.sig" -a "$FORCE" != "1" ]; then
	error "$PRIVATE_DIR.sig file already exists, use --force to overwrite."
fi

# Check for active mounts
if [ "$ALLHOME" = "1" ]; then
	MOUNTPOINT="$HOME"
else
	MOUNTPOINT="$HOME/$PRIVATE_DIR"
fi
CRYPTDIR="$HOME/.$PRIVATE_DIR"
grep -qs "$MOUNTPOINT " /proc/mounts && error "[$MOUNTPOINT] is already mounted"
grep -qs "$CRYPTDIR " /proc/mounts && error "[$CRYPTDIR] is already mounted"

# Check that the mount point and encrypted directory are empty.
# Perhaps one day we could provide a migration mode (using rsync or something),
# but this would be VERY hard to do safely.
count=`ls -Al "$MOUNTPOINT" 2>/dev/null | grep -v "^total" | grep -v "^l.*mount.ecryptfs_private$" | wc -l`
if [ "$count" != "0" ]; then
	error "$MOUNTPOINT must be empty before proceeding"
fi
count=`ls -Al "$CRYPTDIR" 2>/dev/null | grep -v "^total" | wc -l`
if [ "$count" != "0" ]; then
	error "$CRYPTDIR must be empty before proceeding"
fi

stty_orig=`stty -g`
# Prompt for the LOGINPASS, if not on the command line and not in the environment
if [ -z "$LOGINPASS" ]; then
	tries=0
	while [ $tries -lt $PW_ATTEMPTS ]; do
		stty -echo
		read -p "$MESSAGE: " -r LOGINPASS
		stty $stty_orig
		echo
		if [ $WRAPPING_PASS != "LOGIN" ]; then
			stty -echo
			read -p "$MESSAGE (again): " -r LOGINPASS2
			stty $stty_orig
			echo
			if [ "$LOGINPASS" != "$LOGINPASS2" ]; then
				echo "ERROR: Wrapping passphrases must match"
			else
				break
			fi
			tries=$(($tries + 1))
			continue
		fi
		if [ -z "$LOGINPASS" ]; then
			echo "ERROR: You must provide a login passphrase"
			tries=$(($tries + 1))
		else
			if printf "%s\0" "$LOGINPASS" | /sbin/unix_chkpwd "$USER" nullok; then
				break
			else
				echo "ERROR: Your login passphrase is incorrect"
				tries=$(($tries + 1))
			fi
		fi
	done
	if [ $tries -ge $PW_ATTEMPTS ]; then
		echo "ERROR: Too many incorrect password attempts, exiting"
		exit 1
	fi
fi

# Prompt for the MOUNTPASS, if not on the command line and not in the environment
if [ -z "$MOUNTPASS" ]; then
	tries=0
	while [ $tries -lt $PW_ATTEMPTS ]; do
		stty -echo
		read -p "Enter your mount passphrase [leave blank to generate one]: " -r MOUNTPASS
		stty $stty_orig
		echo
		if [ -z "$MOUNTPASS" ]; then
			# Pull 128 bits of random data from /dev/urandom, and convert
			# to a string of 32 hex digits
			MOUNTPASS=`head -c 16 /dev/urandom | od -x | head -n 1 |sed "s/^0000000//" | sed "s/\s*//g"`
			RANDOM_MOUNTPASS=1
			break
		else
			stty -echo
			read -p "Enter your mount passphrase (again): " -r MOUNTPASS2
			stty $stty_orig
			echo
			if [ "$MOUNTPASS" != "$MOUNTPASS2" ]; then
				echo "ERROR: Mount passphrases do not match"
				tries=$(($tries + 1))
			else
				break
			fi
		fi
	done
	if [ $tries -ge $PW_ATTEMPTS ]; then
		echo "ERROR: Too many incorrect passphrase attempts, exiting"
		exit 1
	fi
fi

#echo
#echo "Using username [$USER]"
#echo "Using mount passphrase [$MOUNTPASS]"
#echo "Using login passphrase [$LOGINPASS]"
#echo "Using mount point [$MOUNTPOINT]"
#echo "Using encrypted dir [$CRYPTDIR]"
#echo
#echo "This script will attempt to set up your system to mount"
#echo "$MOUNTPOINT with eCryptfs automatically on login,"
#echo "using your login passphrase."
echo
echo "************************************************************************"
if [ "$RANDOM_MOUNTPASS" = "1" ]; then
	echo "YOU SHOULD RECORD THIS MOUNT PASSPHRASE AND STORE IN A SAFE LOCATION:"
	echo "$MOUNTPASS"
else
	echo "YOU SHOULD RECORD YOUR MOUNT PASSPHRASE AND STORE IN A SAFE LOCATION:"
fi
echo "THIS WILL BE REQUIRED IF YOU NEED TO RECOVER YOUR DATA AT A LATER TIME."
echo "************************************************************************"
echo

###############################################################################

# Setup private directory in home
mkdir -m 700 -p "$CRYPTDIR" || error "Could not create crypt directory [$CRYPTDIR]"
mkdir -m 700 -p "$MOUNTPOINT" || error "Could not create mount directory [$MOUNTPOINT]"
ln -sf /usr/share/ecryptfs-utils/ecryptfs-mount-private.txt "$MOUNTPOINT"/README.txt
ln -sf /usr/share/ecryptfs-utils/ecryptfs-mount-private.desktop "$MOUNTPOINT"/Access-Your-Private-Data.desktop

# Setup ~/.ecryptfs directory
# Packaging must establish /var/lib/ecryptfs, and make writable by users
# wanting to use this feature.
mkdir -m 700 "/var/lib/ecryptfs/$USER"
ln -sf "/var/lib/ecryptfs/$USER" "$HOME/.ecryptfs" || error "$HOME/.ecryptfs seems to already exist"
chmod 500 "$MOUNTPOINT"
touch $HOME/.ecryptfs/auto-mount || error "Could not setup ecryptfs auto-mount"
touch $HOME/.ecryptfs/auto-umount || error "Could not setup ecryptfs auto-umount"
if [ $WRAPPING_PASS = "LOGIN" ]; then
	rm -f $HOME/.ecryptfs/wrapping-independent || error "Could not remove ecryptfs wrapping-independent"
else
	touch $HOME/.ecryptfs/wrapping-independent || error "Could not setup ecryptfs wrapping-independent"
fi


# Backup any existing wrapped-passphrase or sig files; we DO NOT destroy this
timestamp=`date +%Y%m%d%H%M%S`
for i in "$HOME/.ecryptfs/wrapped-passphrase" "$HOME/.ecryptfs/$PRIVATE_DIR.sig"; do
	if [ -s "$i" ]; then
		mv -f "$i" "$i.$timestamp" || error "Could not backup existing data [$i]"
	fi
done

# Setup wrapped-passphrase file
u=`umask`
umask 377
printf "%s\n%s" "$MOUNTPASS" "$LOGINPASS" | ecryptfs-wrap-passphrase "$HOME/.ecryptfs/wrapped-passphrase" - || error "Could not wrap passphrase"
umask $u

# Add the passphrase to current keyring
# On subsequent logins, this should be handled by "pam_ecryptfs.so unwrap"
response=`printf "%s" "$MOUNTPASS" | ecryptfs-add-passphrase -`
if [ $? -ne 0 ]; then
	error "Could not add passphrase to the current keyring"
fi
sig=`echo "$response" | grep "Inserted auth tok" | sed "s/^.*\[//" | sed "s/\].*$//"`
if ! echo "$sig" | egrep -qs "^[0-9a-fA-F]{16,16}$"; then
	error "Could not obtain the key signature"
fi
echo "$sig" > "$HOME/.ecryptfs/$PRIVATE_DIR.sig" || error "Could not create signature file [$HOME/.ecryptfs/$PRIVATE_DIR.sig]"
echo "$MOUNTPOINT" > "$HOME/.ecryptfs/$PRIVATE_DIR.mnt" || error "Could not create mountpoint file [$HOME/.ecryptfs/$PRIVATE_DIR.mnt]"

echo
echo "Done configuring."
echo

# Now let's perform some basic mount/write/umount/read sanity testing...
echo "Testing mount/write/umount/read..."
/sbin/mount.ecryptfs_private || error "Could not mount private ecryptfs directory"
ln -sf "/var/lib/ecryptfs/$USER" "$MOUNTPOINT/.ecryptfs"
temp=`mktemp "$MOUNTPOINT/ecryptfs.test.XXXXXX"` || error_testing "$temp" "Could not create empty file"
random_data=`head -c 16000 /dev/urandom | od -x` || error_testing "$temp" "Could not generate random data"
echo "$random_data" > "$temp" || error_testing "$temp" "Could not write encrypted file"
md5sum1=`md5sum "$temp"` || error_testing "$temp" "Could not read encrypted file"
/sbin/umount.ecryptfs_private || error_testing "$temp" "Could not unmount private ecryptfs directory"
/sbin/mount.ecryptfs_private || error_testing "$temp" "Could not mount private ecryptfs directory (2)"
md5sum2=`md5sum "$temp"` || error_testing "$temp" "Could not read encrypted file (2)"
rm -f "$temp"
/sbin/umount.ecryptfs_private || error_testing "$temp" "Could not unmount private ecryptfs directory (2)"
if [ "$md5sum1" != "$md5sum2" ]; then
	error "Testing failed."
else
	echo "Testing succeeded."
fi

echo
echo "Logout, and log back in to begin using your encrypted directory."
echo
exit 0
